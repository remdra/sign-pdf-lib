import { PDFDocument } from 'pdf-lib';
import { PdfSigner } from './pdf-signer';
import { SignatureInfo } from 'src/models/signature-info';
import { SignatureSettings } from 'src/models/signature-settings';

import PdfPrinter = require('pdfmake');
import streamBuffers = require('stream-buffers');

import { pdfSignerAssets13 } from '../test/_run-assets/pdf-signer/assets-pdf-signer-pdf-13';
import { pdfSignerAssets17 } from '../test/_run-assets/pdf-signer/assets-pdf-signer-pdf-17';
import { pdfSignerAssets17Streams } from '../test/_run-assets/pdf-signer/assets-pdf-signer-pdf-17-streams';
import { settingsAssets } from '../test/_run-assets/pdf-signer/assets-settings';
import { generateAsset } from '../test/_helpers/generate-asset';
import { bufferReplace } from '../test/_helpers/buffer-helpers';

import { use as chaiUse } from 'chai';
import { expect } from 'chai';

const chaiAsPromised = require('chai-as-promised');
chaiUse(chaiAsPromised);

async function generatePdfMakePdfAsync(): Promise<Buffer> {
    const fonts = {
        Helvetica: {
            normal: 'Helvetica',
            bold: 'Helvetica-Bold',
            italics: 'Helvetica-Oblique',
            bolditalics: 'Helvetica-BoldOblique'
          }
    };
    
    const printer = new PdfPrinter(fonts);
    
    const docDefinition = {
        info: {
            title: 'SignPdfLib Test Document',
            author: 'SignPdfLib',
            creator: 'SignPdfLib',
            producer: 'SignPdfLib',
            creationDate: new Date(2023, 1, 23, 9, 0, 0),
            modDate: new Date(2023, 1, 23, 9, 0, 0)
        },
        content: [
            'PDF signing test document generated by PdfMake.'
        ],
        defaultStyle: {
          font: 'Helvetica'
        }
    };
    
    const pdfDoc = printer.createPdfKitDocument(docDefinition);
    const streamBuffer = new streamBuffers.WritableStreamBuffer();
    pdfDoc.pipe(streamBuffer);
    pdfDoc.end();
    return new Promise((resolve) => {
        pdfDoc.on('end', () => {
            resolve(streamBuffer.getContents() as Buffer);
        });
    });
}

async function generatePdfLibPdfAsync(useObjectStreams: boolean = false): Promise<Buffer> {
    const pdfDoc = await PDFDocument.create();
    pdfDoc.setProducer('SignPdfLib');
    pdfDoc.setCreator('SignPdfLib');
    pdfDoc.setCreationDate(new Date(2023, 1, 23, 9, 0, 0));
    pdfDoc.setModificationDate(new Date(2023, 1, 23, 9, 0, 0));

    const page = pdfDoc.addPage();
    const fontSize = 10;
    page.drawText('PDF signing test document generated by PDFLib.', {
        x: 50,
        y: page.getSize().height - 4 * fontSize,
        size: fontSize
    });

    return Buffer.from(await pdfDoc.save({ useObjectStreams }));
}

describe('PdfSigner (pdf 1.3)', function () {

    let pdfSigner: PdfSigner;
    let info: SignatureInfo;
    let settings: SignatureSettings;

    beforeEach(function () {
        info = {
            pageNumber: 1,

            name: 'Test Signer',
            location: 'Timisoara',
            reason: 'Signing',
            modified: new Date(2023, 1, 20, 18, 47, 35), 
            contactInfo: 'signer@semnezonline.ro'
        };
        settings = {
            signatureLength: 4000 - 6,
            rangePlaceHolder: 9999999,
            
            p12Certificate: settingsAssets.p12Certificate,
            pemCertificate: settingsAssets.pemCertificate,
            pemKey: settingsAssets.pemKey,
            certificatePassword: 'password'
        }
        pdfSigner = new PdfSigner(settings);
    });

    it('_generate', async function () {
        const pdf = await generatePdfMakePdfAsync();
        await generateAsset.generateBinaryAsync(pdfSignerAssets13.paths.pdf, pdf);
        
        info.contactInfo = 'signer@semnezonline.ro';
        const signedPdf = await pdfSigner.signAsync(pdf, info);
        const tamperedSignedPdf = bufferReplace(signedPdf, 'signer@semnezonline.ro', 'xxxxxx@xxxxxxxxxxxx.xx');
        await generateAsset.generateBinaryAsync(pdfSignerAssets13.paths.tamperedSignedPdf, tamperedSignedPdf);

        info.contactInfo = 'signer2@semnezonline.ro';
        const tamperedOnlyFirstTwiceSignedPdf = await pdfSigner.signAsync(tamperedSignedPdf, info);
        await generateAsset.generateBinaryAsync(pdfSignerAssets13.paths.tamperedOnlyFirstTwiceSignedPdf, tamperedOnlyFirstTwiceSignedPdf);

        const tamperedAppendedSignedPdf = Buffer.concat([ signedPdf, signedPdf.subarray(pdf.length) ]);
        await generateAsset.generateBinaryAsync(pdfSignerAssets13.paths.tamperedAppendedSignedPdf, tamperedAppendedSignedPdf);
    })

    describe('addPlaceholderAsync', function() {
        it('adds placeholder', async function() {
            const res = await pdfSigner.addPlaceholderAsync(pdfSignerAssets13.pdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets13.paths.placeholderPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets13.placeholderPdf);
        })

        it('adds placeholder for different settings', async function() {
            const pdfSigner = new PdfSigner({ ...settings, signatureLength: 5000, rangePlaceHolder: 9999 });
            const res = await pdfSigner.addPlaceholderAsync(pdfSignerAssets13.pdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets13.paths.differentPlaceholderPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets13.differentPlaceholderPdf);
        })

        it('adds placeholder for empty info', async function() {
            const info: SignatureInfo = {
                pageNumber: 1
            }
            await expect(pdfSigner.addPlaceholderAsync(pdfSignerAssets13.pdf, info)).to.be.fulfilled;
            
            const res = await pdfSigner.addPlaceholderAsync(pdfSignerAssets13.pdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets13.paths.noInfoPlaceholderPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets13.noInfoPlaceholderPdf);
        })
        

        it('throws when not enough space for range', async function() {
            const pdfSigner = new PdfSigner({ ...settings, rangePlaceHolder: 9 });
            
            await expect(pdfSigner.addPlaceholderAsync(pdfSignerAssets13.pdf, info)).to.be.rejected;
        })

        it('adds placeholder with image', async function() {
            info.visual = {
                jpgImage: pdfSignerAssets13.signatureImage,
                imageRectangle: { left: 50.0, top: 741.9 - 100, right: 50.0 + 214.0, bottom: 741.9 - 100 + 70 }
            };
            const res = await pdfSigner.addPlaceholderAsync(pdfSignerAssets13.pdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets13.paths.imagePlaceholderPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets13.imagePlaceholderPdf);
        })
    })

    describe('signAsync', function() {
        it('signs document', async function() {
            const res = await pdfSigner.signAsync(pdfSignerAssets13.pdf, info);
            
            await generateAsset.generateBinaryAsync(pdfSignerAssets13.paths.signedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets13.signedPdf);
        })

        it('signs already signed document', async function() {
            const res = await pdfSigner.signAsync(pdfSignerAssets13.signedPdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets13.paths.twiceSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets13.twiceSignedPdf);
        })

        it('throws when not enough space for signature', async function() {
            const pdfSigner = new PdfSigner({ ...settings, signatureLength: 200 });
            
            await expect(pdfSigner.signAsync(pdfSignerAssets13.pdf, info)).to.be.rejected;
        })

        it('signs with image', async function() {
            info.visual = {
                jpgImage: pdfSignerAssets13.signatureImage,
                imageRectangle: { left: 50.0, top: 741.9 - 100, right: 50.0 + 214.0, bottom: 741.9 - 100 + 70 }
            };
            const signedPdf = await pdfSigner.signAsync(pdfSignerAssets13.pdf, info);
            info.visual.imageRectangle.left += 250;
            info.visual.imageRectangle.right += 250;
            const twiceSignedPdf = await pdfSigner.signAsync(signedPdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets13.paths.imageTwiceSignedPdf, twiceSignedPdf);
            expect(twiceSignedPdf).to.be.deep.equal(pdfSignerAssets13.imageTwiceSignedPdf);
        })

        it('works for missing p12 certificate', async function() {
            const pdfSigner = new PdfSigner({ ...settings, p12Certificate: undefined });

            await expect(pdfSigner.signAsync(pdfSignerAssets13.pdf, info)).to.be.fulfilled;
        })

        it('works for missing pem certificate', async function() {
            const pdfSigner = new PdfSigner({ ...settings, pemCertificate: undefined });

            await expect(pdfSigner.signAsync(pdfSignerAssets13.pdf, info)).to.be.fulfilled;
        })

        it('works for missing pem key', async function() {
            const pdfSigner = new PdfSigner({ ...settings, pemKey: undefined });

            await expect(pdfSigner.signAsync(pdfSignerAssets13.pdf, info)).to.be.fulfilled;
        })

        it('throws for missing p12 certificate, pem certificate and pem key', async function() {
            const pdfSigner = new PdfSigner({ ...settings, p12Certificate: undefined, pemCertificate: undefined, pemKey: undefined });

            await expect(pdfSigner.signAsync(pdfSignerAssets13.pdf, info)).to.be.rejected;
        })
    })

    describe('verifySignaturesAsync', function() {
        it('returns undefined for no signatures', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets13.pdf);
            expect(res).to.be.undefined;
        })

        it('validates one signature', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets13.signedPdf);

            await generateAsset.generateJsonAsync(pdfSignerAssets13.paths.checkSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets13.checkSignedPdf);
        })

        it('validates two signatures', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets13.twiceSignedPdf);

            await generateAsset.generateJsonAsync(pdfSignerAssets13.paths.checkTwiceSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets13.checkTwiceSignedPdf);
        })

        it('detects tampered signature', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets13.tamperedSignedPdf);

            await generateAsset.generateJsonAsync(pdfSignerAssets13.paths.checkTamperedSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets13.checkTamperedSignedPdf);
        })

        it('detects only first tampered signature', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets13.tamperedOnlyFirstTwiceSignedPdf);

            await generateAsset.generateJsonAsync(pdfSignerAssets13.paths.checkTamperedOnlyFirstTwiceSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets13.checkTamperedOnlyFirstTwiceSignedPdf);
        })

        it('detects tampered appended pdf', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets13.tamperedAppendedSignedPdf);

            await generateAsset.generateJsonAsync(pdfSignerAssets13.paths.checkTamperedAppendedSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets13.checkTamperedAppendedSignedPdf);
        })
    })
})

describe('PdfSigner (pdf 1.7)', function () {

    let pdfSigner: PdfSigner;
    let info: SignatureInfo;
    let settings: SignatureSettings;

    beforeEach(function () {
        info = {
            pageNumber: 1,

            name: 'Test Signer',
            location: 'Timisoara',
            reason: 'Signing',
            modified: new Date(2023, 1, 20, 18, 47, 35), 
            contactInfo: 'signer@semnezonline.ro'
        };
        settings = {
            signatureLength: 4000 - 6,
            rangePlaceHolder: 9999999,
            
            p12Certificate: settingsAssets.p12Certificate,
            pemCertificate: settingsAssets.pemCertificate,
            pemKey: settingsAssets.pemKey,
            certificatePassword: 'password'
        }
        pdfSigner = new PdfSigner(settings);
    });

    it('_generate', async function () {
        const pdf = await generatePdfLibPdfAsync();
        await generateAsset.generateBinaryAsync(pdfSignerAssets17.paths.pdf, pdf);
        
        info.contactInfo = 'signer@semnezonline.ro';
        const signedPdf = await pdfSigner.signAsync(pdf, info);
        const tamperedSignedPdf = bufferReplace(signedPdf, 'signer@semnezonline.ro', 'xxxxxx@xxxxxxxxxxxx.xx');
        await generateAsset.generateBinaryAsync(pdfSignerAssets17.paths.tamperedSignedPdf, tamperedSignedPdf);

        info.contactInfo = 'signer2@semnezonline.ro';
        const tamperedOnlyFirstTwiceSignedPdf = await pdfSigner.signAsync(tamperedSignedPdf, info);
        await generateAsset.generateBinaryAsync(pdfSignerAssets17.paths.tamperedOnlyFirstTwiceSignedPdf, tamperedOnlyFirstTwiceSignedPdf);

        const tamperedAppendedSignedPdf = Buffer.concat([ signedPdf, signedPdf.subarray(pdf.length) ]);
        await generateAsset.generateBinaryAsync(pdfSignerAssets17.paths.tamperedAppendedSignedPdf, tamperedAppendedSignedPdf);
    })

    describe('addPlaceholderAsync', function() {
        it('adds placeholder', async function() {
            const res = await pdfSigner.addPlaceholderAsync(pdfSignerAssets17.pdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets17.paths.placeholderPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17.placeholderPdf);
        })

        it('adds placeholder for different settings', async function() {
            const pdfSigner = new PdfSigner({ ...settings, signatureLength: 5000, rangePlaceHolder: 9999 });
            const res = await pdfSigner.addPlaceholderAsync(pdfSignerAssets17.pdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets17.paths.differentPlaceholderPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17.differentPlaceholderPdf);
        })

        it('adds placeholder for empty info', async function() {
            const info: SignatureInfo = {
                pageNumber: 1
            }
            await expect(pdfSigner.addPlaceholderAsync(pdfSignerAssets17.pdf, info)).to.be.fulfilled;
            
            const res = await pdfSigner.addPlaceholderAsync(pdfSignerAssets17.pdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets17.paths.noInfoPlaceholderPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17.noInfoPlaceholderPdf);
        })
        

        it('throws when not enough space for range', async function() {
            const pdfSigner = new PdfSigner({ ...settings, rangePlaceHolder: 9 });
            
            await expect(pdfSigner.addPlaceholderAsync(pdfSignerAssets17.pdf, info)).to.be.rejected;
        })

        it('adds placeholder with image', async function() {
            info.visual = {
                jpgImage: pdfSignerAssets17.signatureImage,
                imageRectangle: { left: 50.0, top: 741.9 - 100, right: 50.0 + 214.0, bottom: 741.9 - 100 + 70 }
            };
            const res = await pdfSigner.addPlaceholderAsync(pdfSignerAssets17.pdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets17.paths.imagePlaceholderPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17.imagePlaceholderPdf);
        })
    })

    describe('signAsync', function() {
        it('signs document', async function() {
            const res = await pdfSigner.signAsync(pdfSignerAssets17.pdf, info);
            
            await generateAsset.generateBinaryAsync(pdfSignerAssets17.paths.signedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17.signedPdf);
        })

        it('signs already signed document', async function() {
            const res = await pdfSigner.signAsync(pdfSignerAssets17.signedPdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets17.paths.twiceSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17.twiceSignedPdf);
        })

        it('throws when not enough space for signature', async function() {
            const pdfSigner = new PdfSigner({ ...settings, signatureLength: 200 });
            
            await expect(pdfSigner.signAsync(pdfSignerAssets17.pdf, info)).to.be.rejected;
        })

        it('signs with image', async function() {
            info.visual = {
                jpgImage: pdfSignerAssets17.signatureImage,
                imageRectangle: { left: 50.0, top: 741.9 - 100, right: 50.0 + 214.0, bottom: 741.9 - 100 + 70 }
            };
            const signedPdf = await pdfSigner.signAsync(pdfSignerAssets17.pdf, info);
            info.visual.imageRectangle.left += 250;
            info.visual.imageRectangle.right += 250;
            const twiceSignedPdf = await pdfSigner.signAsync(signedPdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets17.paths.imageTwiceSignedPdf, twiceSignedPdf);
            expect(twiceSignedPdf).to.be.deep.equal(pdfSignerAssets17.imageTwiceSignedPdf);
        })

        it('works for missing p12 certificate', async function() {
            const pdfSigner = new PdfSigner({ ...settings, p12Certificate: undefined });

            await expect(pdfSigner.signAsync(pdfSignerAssets17.pdf, info)).to.be.fulfilled;
        })

        it('works for missing pem certificate', async function() {
            const pdfSigner = new PdfSigner({ ...settings, pemCertificate: undefined });

            await expect(pdfSigner.signAsync(pdfSignerAssets17.pdf, info)).to.be.fulfilled;
        })

        it('works for missing pem key', async function() {
            const pdfSigner = new PdfSigner({ ...settings, pemKey: undefined });

            await expect(pdfSigner.signAsync(pdfSignerAssets17.pdf, info)).to.be.fulfilled;
        })

        it('throws for missing p12 certificate, pem certificate and pem key', async function() {
            const pdfSigner = new PdfSigner({ ...settings, p12Certificate: undefined, pemCertificate: undefined, pemKey: undefined });

            await expect(pdfSigner.signAsync(pdfSignerAssets17.pdf, info)).to.be.rejected;
        })
    })

    describe('verifySignaturesAsync', function() {
        it('returns undefined for no signatures', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets17.pdf);
            expect(res).to.be.undefined;
        })

        it('validates one signature', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets17.signedPdf);

            await generateAsset.generateJsonAsync(pdfSignerAssets17.paths.checkSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17.checkSignedPdf);
        })

        it('validates two signatures', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets17.twiceSignedPdf);

            await generateAsset.generateJsonAsync(pdfSignerAssets17.paths.checkTwiceSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17.checkTwiceSignedPdf);
        })

        it('detects tampered signature', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets17.tamperedSignedPdf);

            await generateAsset.generateJsonAsync(pdfSignerAssets17.paths.checkTamperedSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17.checkTamperedSignedPdf);
        })

        it('detects only first tampered signature', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets17.tamperedOnlyFirstTwiceSignedPdf);

            await generateAsset.generateJsonAsync(pdfSignerAssets17.paths.checkTamperedOnlyFirstTwiceSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17.checkTamperedOnlyFirstTwiceSignedPdf);
        })

        it('detects tampered appended pdf', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets17.tamperedAppendedSignedPdf);

            await generateAsset.generateJsonAsync(pdfSignerAssets17.paths.checkTamperedAppendedSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17.checkTamperedAppendedSignedPdf);
        })
    })
})

describe('PdfSigner (pdf 1.7 streams)', function () {

    let pdfSigner: PdfSigner;
    let info: SignatureInfo;
    let settings: SignatureSettings;

    beforeEach(function () {
        info = {
            pageNumber: 1,

            name: 'Test Signer',
            location: 'Timisoara',
            reason: 'Signing',
            modified: new Date(2023, 1, 20, 18, 47, 35), 
            contactInfo: 'signer@semnezonline.ro'
        };
        settings = {
            signatureLength: 4000 - 6,
            rangePlaceHolder: 9999999,
            
            p12Certificate: settingsAssets.p12Certificate,
            pemCertificate: settingsAssets.pemCertificate,
            pemKey: settingsAssets.pemKey,
            certificatePassword: 'password'
        }
        pdfSigner = new PdfSigner(settings);
    });

    it('_generate', async function () {
        const pdf = await generatePdfLibPdfAsync(true);
        await generateAsset.generateBinaryAsync(pdfSignerAssets17Streams.paths.pdf, pdf);
        
        info.contactInfo = 'signer@semnezonline.ro';
        const signedPdf = await pdfSigner.signAsync(pdf, info);
        const tamperedSignedPdf = bufferReplace(signedPdf, 'signer@semnezonline.ro', 'xxxxxx@xxxxxxxxxxxx.xx');
        await generateAsset.generateBinaryAsync(pdfSignerAssets17Streams.paths.tamperedSignedPdf, tamperedSignedPdf);

        info.contactInfo = 'signer2@semnezonline.ro';
        const tamperedOnlyFirstTwiceSignedPdf = await pdfSigner.signAsync(tamperedSignedPdf, info);
        await generateAsset.generateBinaryAsync(pdfSignerAssets17Streams.paths.tamperedOnlyFirstTwiceSignedPdf, tamperedOnlyFirstTwiceSignedPdf);

        const tamperedAppendedSignedPdf = Buffer.concat([ signedPdf, signedPdf.subarray(pdf.length) ]);
        await generateAsset.generateBinaryAsync(pdfSignerAssets17Streams.paths.tamperedAppendedSignedPdf, tamperedAppendedSignedPdf);
    })

    describe('addPlaceholderAsync', function() {
        it('adds placeholder', async function() {
            const res = await pdfSigner.addPlaceholderAsync(pdfSignerAssets17Streams.pdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets17Streams.paths.placeholderPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17Streams.placeholderPdf);
        })

        it('adds placeholder for different settings', async function() {
            const pdfSigner = new PdfSigner({ ...settings, signatureLength: 5000, rangePlaceHolder: 9999 });
            const res = await pdfSigner.addPlaceholderAsync(pdfSignerAssets17Streams.pdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets17Streams.paths.differentPlaceholderPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17Streams.differentPlaceholderPdf);
        })

        it('adds placeholder for empty info', async function() {
            const info: SignatureInfo = {
                pageNumber: 1
            }
            await expect(pdfSigner.addPlaceholderAsync(pdfSignerAssets17Streams.pdf, info)).to.be.fulfilled;
            
            const res = await pdfSigner.addPlaceholderAsync(pdfSignerAssets17Streams.pdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets17Streams.paths.noInfoPlaceholderPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17Streams.noInfoPlaceholderPdf);
        })
        

        it('throws when not enough space for range', async function() {
            const pdfSigner = new PdfSigner({ ...settings, rangePlaceHolder: 9 });
            
            await expect(pdfSigner.addPlaceholderAsync(pdfSignerAssets17Streams.pdf, info)).to.be.rejected;
        })

        it('adds placeholder with image', async function() {
            info.visual = {
                jpgImage: pdfSignerAssets17Streams.signatureImage,
                imageRectangle: { left: 50.0, top: 741.9 - 100, right: 50.0 + 214.0, bottom: 741.9 - 100 + 70 }
            }
            const res = await pdfSigner.addPlaceholderAsync(pdfSignerAssets17Streams.pdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets17Streams.paths.imagePlaceholderPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17Streams.imagePlaceholderPdf);
        })
    })

    describe('signAsync', function() {
        it('signs document', async function() {
            const res = await pdfSigner.signAsync(pdfSignerAssets17Streams.pdf, info);
            
            await generateAsset.generateBinaryAsync(pdfSignerAssets17Streams.paths.signedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17Streams.signedPdf);
        })

        it('signs already signed document', async function() {
            const res = await pdfSigner.signAsync(pdfSignerAssets17Streams.signedPdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets17Streams.paths.twiceSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17Streams.twiceSignedPdf);
        })

        it('throws when not enough space for signature', async function() {
            const pdfSigner = new PdfSigner({ ...settings, signatureLength: 200 });
            
            await expect(pdfSigner.signAsync(pdfSignerAssets17Streams.pdf, info)).to.be.rejected;
        })

        it('signs with image', async function() {
            info.visual = {
                jpgImage: pdfSignerAssets17Streams.signatureImage,
                imageRectangle: { left: 50.0, top: 741.9 - 100, right: 50.0 + 214.0, bottom: 741.9 - 100 + 70 }
            };
            const signedPdf = await pdfSigner.signAsync(pdfSignerAssets17Streams.pdf, info);
            info.visual.imageRectangle.left += 250;
            info.visual.imageRectangle.right += 250;
            const twiceSignedPdf = await pdfSigner.signAsync(signedPdf, info);

            await generateAsset.generateBinaryAsync(pdfSignerAssets17Streams.paths.imageTwiceSignedPdf, twiceSignedPdf);
            expect(twiceSignedPdf).to.be.deep.equal(pdfSignerAssets17Streams.imageTwiceSignedPdf);
        })

        it('works for missing p12 certificate', async function() {
            const pdfSigner = new PdfSigner({ ...settings, p12Certificate: undefined });

            await expect(pdfSigner.signAsync(pdfSignerAssets17Streams.pdf, info)).to.be.fulfilled;
        })

        it('works for missing pem certificate', async function() {
            const pdfSigner = new PdfSigner({ ...settings, pemCertificate: undefined });

            await expect(pdfSigner.signAsync(pdfSignerAssets17Streams.pdf, info)).to.be.fulfilled;
        })

        it('works for missing pem key', async function() {
            const pdfSigner = new PdfSigner({ ...settings, pemKey: undefined });

            await expect(pdfSigner.signAsync(pdfSignerAssets17Streams.pdf, info)).to.be.fulfilled;
        })

        it('throws for missing p12 certificate, pem certificate and pem key', async function() {
            const pdfSigner = new PdfSigner({ ...settings, p12Certificate: undefined, pemCertificate: undefined, pemKey: undefined });

            await expect(pdfSigner.signAsync(pdfSignerAssets17Streams.pdf, info)).to.be.rejected;
        })
    })

    describe('verifySignaturesAsync', function() {
        it('returns undefined for no signatures', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets17Streams.pdf);
            expect(res).to.be.undefined;
        })

        it('validates one signature', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets17Streams.signedPdf);

            await generateAsset.generateJsonAsync(pdfSignerAssets17Streams.paths.checkSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17Streams.checkSignedPdf);
        })

        it('validates two signatures', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets17Streams.twiceSignedPdf);

            await generateAsset.generateJsonAsync(pdfSignerAssets17Streams.paths.checkTwiceSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17Streams.checkTwiceSignedPdf);
        })

        it('detects tampered signature', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets17Streams.tamperedSignedPdf);

            await generateAsset.generateJsonAsync(pdfSignerAssets17Streams.paths.checkTamperedSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17Streams.checkTamperedSignedPdf);
        })

        it('detects only first tampered signature', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets17Streams.tamperedOnlyFirstTwiceSignedPdf);

            await generateAsset.generateJsonAsync(pdfSignerAssets17Streams.paths.checkTamperedOnlyFirstTwiceSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17Streams.checkTamperedOnlyFirstTwiceSignedPdf);
        })

        it('detects tampered appended pdf', async function() {
            const res = await pdfSigner.verifySignaturesAsync(pdfSignerAssets17Streams.tamperedAppendedSignedPdf);

            await generateAsset.generateJsonAsync(pdfSignerAssets17Streams.paths.checkTamperedAppendedSignedPdf, res);
            expect(res).to.be.deep.equal(pdfSignerAssets17Streams.checkTamperedAppendedSignedPdf);
        })
    })
})
